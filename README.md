# Adaptive ANN Inverse Control of a DC Motor

## üìù Project Overview
This project implements an **Adaptive Artificial Neural Network (ANN) Inverse Controller** for a DC motor driving a nonlinear pump load. The goal is to force a nonlinear physical system to track a reference speed profile by learning its inverse dynamics.

The project demonstrates a complex co-simulation workflow:
1.  **Physical Modeling:** Simulating a DC motor with nonlinear load dynamics in **MATLAB/Simulink**.
2.  **Data Engineering:** Generating synthetic training data using random excitation signals.
3.  **Machine Learning:** Training a Neural Network Regressor in **Python (scikit-learn)** to learn the inverse model of the plant.
4.  **Real-Time Control:** Deploying the trained Python model back into Simulink to control the motor in real-time.

## ‚öôÔ∏è System Dynamics
The system under control is a DC Motor coupled with a fan/pump load. It is defined by the following differential equations:

### 1. Electrical Subsystem
$$L \frac{di(t)}{dt} = v(t) - R i(t) - K_m \omega(t)$$

### 2. Mechanical Subsystem
$$J \frac{d\omega(t)}{dt} = K_m i(t) - B \omega(t) - \mu \omega^2(t) \cdot \text{sign}(\omega(t))$$

**Key Parameters:**
* **Nonlinearity:** The term $\mu \omega^2(t)$ represents the aerodynamic drag of the fan, making the system nonlinear and difficult for standard linear controllers.
* **Inertia ($J$):** 0.068 Kg.m¬≤
* **Inductance ($L$):** 0.055 H

## üìÇ Repository Structure

### Simulation Files
* **`Identification.slx`**: Simulink model used to excite the system and generate training data.
* **`Control.slx`**: Simulink model used for the final testing. Contains the MATLAB Function block acting as the ANN controller.

### Scripts
* **`aplication2excel.m`**: MATLAB script that processes simulation output and formats it for the Neural Network (Time-shifting inputs: $y(k), y(k-1), y(k-2)$).
* **`train_ann_identifier.py`**: Python script that reads the Excel data, scales it, trains an `MLPRegressor`, and saves the model.

### Data & Models
* **`ann_training_data.xlsx`**: The dataset generated by the identification phase.
* **`ann_identifier_model.pkl`**: The trained Neural Network model.
* **`ann_identifier_scaler.pkl`**: The trained StandardScaler.

## üöÄ Workflow & Usage

### Phase 1: Identification (Data Gathering)
1.  Open **`Identification.slx`**.
2.  **Simulation Settings:**
    * Input: Sinusoidal wave + Random Noise.
    * **CRITICAL:** Amplitude set to **40V** and Frequency to **3.14 rad/s** (0.5 Hz) to fully excite the motor's dynamics.
3.  Run the simulation to generate `u_data` and `y_data`.
4.  Run **`aplication2excel.m`** to export this data to `ann_training_data.xlsx`.

### Phase 2: Training (Machine Learning)
1.  Run **`train_ann_identifier.py`**.
2.  The script performs the following:
    * Loads the Excel data.
    * Scales the features using `StandardScaler` (trained on raw values to avoid feature-name errors).
    * Trains an **MLPRegressor** (ReLU activation, Adam solver).
    * Exports the `.pkl` files for deployment.

### Phase 3: Control (Testing)
1.  Open **`Control.slx`**.
2.  Ensure the `.pkl` files are in the same directory.
3.  **Simulation Settings:** Reference speed set to amplitude **10 rad/s** at **3.14 rad/s**.
4.  Run the simulation.
5.  Observe the Scope: The system output $y(k)$ should track the reference $y_{ref}(k)$ accurately.

## üîß Engineering Challenges & Solutions

This project overcame several significant implementation hurdles:

### 1. The "Stiff" System & Solver Crashes
* **Problem:** The motor has a fast electrical time constant ($\tau \approx 7ms$) but a slow mechanical response. Using a variable-step solver caused the simulation to crash (`NaN` errors) or run inefficiently.
* **Solution:** Implemented a **Fixed-Step Solver (`ode4`)** with a step size of **0.001s (`1e-3`)**. This captures the fast electrical dynamics without crashing the simulation.

### 2. Multi-Rate Simulation (The ZOH Fix)
* **Problem:** The Neural Network controller is digital ($T_s=0.04s$), but the plant is continuous. Running the controller at the solver speed ($0.001s$) caused massive computational overhead.
* **Solution:** Used **Zero-Order Hold (ZOH)** blocks to sample signals at 0.04s. This reduced the Python function calls from 1000/sec to 25/sec, speeding up the simulation by **40x**.

### 3. Physical Constraints & "Garbage In, Garbage Out"
* **Problem:** Initial theoretical parameters (314 rad/s, 2V amplitude) failed to move the heavy motor ($J=0.068$). The ANN learned that "voltage has no effect," leading to controller failure.
* **Solution:** Adjusted the identification signal to **3.14 rad/s (0.5 Hz)** and **40V**. This physically moved the motor to high speeds (~12 rad/s), providing the ANN with the high-quality data needed to learn the inverse model.

### 4. MATLAB-Python Bridge
* **Problem:** Simulink Coder cannot compile native Python code.
* **Solution:** Used `coder.extrinsic` to declare Python functions as external. Implemented a robust MATLAB wrapper using `feval` and `int32` type-casting to safely pass data between the Simulink C++ environment and the Python interpreter.

## üì¶ Requirements
* MATLAB & Simulink (R2021a or newer recommended)
* Python 3.8+
* `scikit-learn`, `pandas`, `numpy`, `joblib`

---
*Created for the Modern Control Systems Course.*
